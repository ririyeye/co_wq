#include "syswork.hpp"

#if defined(USING_NET)

#include "fd_base.hpp"
#include "semaphore.hpp"
#include "tcp_listener.hpp"
#include "tcp_socket.hpp"
#include "when_all.hpp"

#if defined(USING_SSL)
#include "tls.hpp"
#endif

#include <nlohmann/json.hpp>

#include <atomic>
#include <chrono>
#include <cstdint>
#include <cstdio>
#include <deque>
#include <filesystem>
#include <limits>
#include <memory>
#include <mutex>
#include <optional>
#include <spdlog/spdlog.h>
#include <string>
#include <string_view>
#include <system_error>
#include <thread>
#include <unordered_map>
#include <utility>
#include <vector>

#if defined(_WIN32)
#include <windows.h>
#include <ws2tcpip.h>

#else
#include <csignal>
#include <netdb.h>
#include <sys/socket.h>
#endif

using namespace co_wq;

namespace {

std::filesystem::path find_project_root(const std::filesystem::path& start_dir)
{
    std::error_code ec;
    auto            current = std::filesystem::weakly_canonical(start_dir, ec);
    if (ec)
        current = start_dir;

    while (!current.empty()) {
        auto candidate_xmake = current / "xmake.lua";
        if (std::filesystem::exists(candidate_xmake, ec) && !ec)
            return current;

        auto candidate_git = current / ".git";
        if (std::filesystem::exists(candidate_git, ec) && !ec)
            return current;

        auto parent = current.parent_path();
        if (parent == current)
            break;
        current = std::move(parent);
    }

    return {};
}

constexpr uint8_t  kFrameTypeControl = 0x01;
constexpr uint8_t  kFrameTypeData    = 0x02;
constexpr uint32_t kMaxPayloadBytes  = 4u * 1024u * 1024u; // 4 MiB upper bound per frame

using NetFdWorkqueue = net::fd_workqueue<SpinLock, net::epoll_reactor>;

std::string format_endpoint(const sockaddr* addr, socklen_t len)
{
    if (!addr || len == 0)
        return "unknown";

    char host[NI_MAXHOST] = { 0 };
    char serv[NI_MAXSERV] = { 0 };
    int  rc = ::getnameinfo(addr, len, host, sizeof(host), serv, sizeof(serv), NI_NUMERICHOST | NI_NUMERICSERV);
    if (rc != 0) {
#if defined(_WIN32)
        (void)rc;
#endif
        return "unknown";
    }

    std::string host_str(host);
    std::string serv_str(serv);

    if (addr->sa_family == AF_INET6 && !host_str.empty())
        host_str = "[" + host_str + "]";
    else if (host_str.empty())
        host_str = "unknown";

    if (!serv_str.empty())
        return host_str + ':' + serv_str;
    return host_str;
}

std::string describe_native_fd(net::os::fd_t fd)
{
    if (fd == net::os::invalid_fd())
        return "invalid";
    sockaddr_storage addr {};
    socklen_t        len = static_cast<socklen_t>(sizeof(addr));
#if defined(_WIN32)
    if (::getpeername(fd, reinterpret_cast<sockaddr*>(&addr), &len) != 0)
        return "unknown";
#else
    if (::getpeername(static_cast<int>(fd), reinterpret_cast<sockaddr*>(&addr), &len) != 0)
        return "unknown";
#endif
    return format_endpoint(reinterpret_cast<sockaddr*>(&addr), len);
}

template <typename Socket> std::string describe_socket(Socket& socket)
{
    if constexpr (requires(Socket& s) { s.underlying(); }) {
        return describe_socket(socket.underlying());
    } else if constexpr (requires(Socket& s) { s.native_handle(); }) {
        return describe_native_fd(socket.native_handle());
    } else {
        return "unknown";
    }
}

struct Frame {
    uint8_t              type { 0 };
    std::vector<uint8_t> payload; // payload body only
    std::vector<uint8_t> raw;     // header + payload for forwarding
};

struct HandshakeInfo {
    std::string room;
    std::string client_id;
    uint32_t    send_plan { 0 };
    uint32_t    payload_bytes { 0 };
    uint32_t    expect_receive { 0 };
    uint32_t    server_push { 0 };
    bool        shutdown_after_send { true };
    uint32_t    wait_timeout_ms { 30000 };
    bool        solo_mode { false };
};

struct ServerContext; // forward declaration for ChatSession wait timer callbacks

struct ChatSession : std::enable_shared_from_this<ChatSession> {
    explicit ChatSession(workqueue<SpinLock>& wq, Timer_check_queue<SpinLock>& tq)
        : send_sem(std::make_unique<Semaphore<SpinLock>>(wq, 0, std::numeric_limits<int>::max())), exec(&wq), timer(&tq)
    {
    }

    HandshakeInfo info;

    std::chrono::steady_clock::time_point handshake_time { std::chrono::steady_clock::now() };
    std::chrono::steady_clock::time_point ready_time {};
    std::chrono::steady_clock::time_point finish_time {};

    std::weak_ptr<ChatSession> peer;

    uint64_t forwarded_to_peer { 0 };    // frames received from client and forwarded to peer
    uint64_t received_from_peer { 0 };   // frames delivered to client from peer
    uint64_t server_generated { 0 };     // frames generated by server and delivered
    uint64_t client_reported_done { 0 }; // frames reported via done message

    bool handshake_done { false };
    bool ready_sent { false };
    bool summary_sent { false };
    bool closing { false };
    bool peer_gone { false };

    std::string last_error;

    std::mutex                           send_mutex;
    std::deque<std::vector<uint8_t>>     send_queue;
    std::unique_ptr<Semaphore<SpinLock>> send_sem;
    bool                                 writer_stop_enqueued { false };
    std::mutex                           pending_mutex;
    std::deque<std::vector<uint8_t>>     pending_to_peer;
    workqueue<SpinLock>*                 exec { nullptr };
    Timer_check_queue<SpinLock>*         timer { nullptr };
    struct WaitTimer : Timer_worknode<SpinLock> {
        std::weak_ptr<ChatSession> session;
        ServerContext*             server { nullptr };
    } wait_timer;
    bool        wait_timer_armed { false };
    std::string remote_address;
    int         alloc_start { 0 };
    int         free_start { 0 };

    void enqueue_frame(std::vector<uint8_t>&& frame)
    {
        {
            std::lock_guard lock(send_mutex);
            send_queue.emplace_back(std::move(frame));
        }
        send_sem->release();
    }

    void request_writer_stop()
    {
        bool need_notify = false;
        {
            std::lock_guard lock(send_mutex);
            if (!writer_stop_enqueued) {
                send_queue.emplace_back(); // empty sentinel
                writer_stop_enqueued = true;
                need_notify          = true;
            }
        }
        if (need_notify)
            send_sem->release();
    }

    void append_pending(std::vector<uint8_t>&& raw)
    {
        std::lock_guard lock(pending_mutex);
        pending_to_peer.emplace_back(std::move(raw));
    }

    std::deque<std::vector<uint8_t>> take_pending()
    {
        std::lock_guard lock(pending_mutex);
        auto            out = std::move(pending_to_peer);
        pending_to_peer.clear();
        return out;
    }
};

struct MetricsAggregator {
    std::atomic<uint64_t> total_connections { 0 };
    std::atomic<uint64_t> active_connections { 0 };
    std::atomic<uint64_t> total_pairings { 0 };
    std::atomic<uint64_t> total_errors { 0 };
};

struct RoomRegistry {
    std::mutex                                                  mutex;
    std::unordered_map<std::string, std::weak_ptr<ChatSession>> waiting;

    std::shared_ptr<ChatSession> attach(const std::shared_ptr<ChatSession>& session)
    {
        std::lock_guard lock(mutex);
        auto            it = waiting.find(session->info.room);
        if (it == waiting.end()) {
            waiting.emplace(session->info.room, session);
            return nullptr;
        }
        auto existing = it->second.lock();
        if (!existing || existing->closing) {
            it->second = session;
            return nullptr;
        }
        waiting.erase(it);
        return existing;
    }

    void remove_if_waiting(const std::shared_ptr<ChatSession>& session)
    {
        std::lock_guard lock(mutex);
        auto            it = waiting.find(session->info.room);
        if (it != waiting.end()) {
            auto locked = it->second.lock();
            if (!locked || locked.get() == session.get())
                waiting.erase(it);
        }
    }
};

struct ServerContext {
    RoomRegistry&                rooms;
    MetricsAggregator&           metrics;
    Timer_check_queue<SpinLock>& timer;
    uint32_t                     max_payload { kMaxPayloadBytes };
};

static void wait_timeout_callback(worknode* work);
void        cancel_wait_timeout(const std::shared_ptr<ChatSession>& session);
void        arm_wait_timeout(ServerContext& server, const std::shared_ptr<ChatSession>& session);

std::atomic_bool                      g_stop { false };
std::atomic<net::os::fd_t>            g_listener_fd { net::os::invalid_fd() };
MetricsAggregator                     g_metrics;
RoomRegistry                          g_rooms;
std::chrono::steady_clock::time_point g_start_time;
std::atomic<int>                      g_handle_connection_active { 0 };

#if defined(_WIN32)
BOOL WINAPI console_ctrl_handler(DWORD type)
{
    if (type == CTRL_C_EVENT) {
        g_stop.store(true, std::memory_order_release);
        auto fd = g_listener_fd.exchange(net::os::invalid_fd(), std::memory_order_acq_rel);
        if (fd != net::os::invalid_fd())
            net::os::close_fd(fd);
        return TRUE;
    }
    return FALSE;
}
#else
void sigint_handler(int)
{
    g_stop.store(true, std::memory_order_release);
    auto fd = g_listener_fd.exchange(net::os::invalid_fd(), std::memory_order_acq_rel);
    if (fd != net::os::invalid_fd())
        net::os::close_fd(fd);
}
#endif

std::vector<uint8_t> make_frame(uint8_t type, std::string_view payload)
{
    if (payload.size() > std::numeric_limits<uint32_t>::max())
        throw std::runtime_error("payload too large");
    std::vector<uint8_t> frame;
    frame.reserve(5 + payload.size());
    frame.push_back(type);
    uint32_t len = static_cast<uint32_t>(payload.size());
    frame.push_back(static_cast<uint8_t>((len >> 24) & 0xFF));
    frame.push_back(static_cast<uint8_t>((len >> 16) & 0xFF));
    frame.push_back(static_cast<uint8_t>((len >> 8) & 0xFF));
    frame.push_back(static_cast<uint8_t>(len & 0xFF));
    frame.insert(frame.end(), payload.begin(), payload.end());
    return frame;
}

std::vector<uint8_t> make_frame(uint8_t type, const std::vector<uint8_t>& payload)
{
    if (payload.size() > std::numeric_limits<uint32_t>::max())
        throw std::runtime_error("payload too large");
    std::vector<uint8_t> frame;
    frame.reserve(5 + payload.size());
    frame.push_back(type);
    uint32_t len = static_cast<uint32_t>(payload.size());
    frame.push_back(static_cast<uint8_t>((len >> 24) & 0xFF));
    frame.push_back(static_cast<uint8_t>((len >> 16) & 0xFF));
    frame.push_back(static_cast<uint8_t>((len >> 8) & 0xFF));
    frame.push_back(static_cast<uint8_t>(len & 0xFF));
    frame.insert(frame.end(), payload.begin(), payload.end());
    return frame;
}

uint64_t read_u64_be(const uint8_t* data)
{
    uint64_t value = 0;
    for (int i = 0; i < 8; ++i)
        value = (value << 8) | static_cast<uint64_t>(data[i]);
    return value;
}

std::vector<uint8_t> make_binary_payload(uint64_t seq, const std::vector<uint8_t>& body)
{
    std::vector<uint8_t> payload;
    payload.reserve(8 + body.size());
    for (int shift = 56; shift >= 0; shift -= 8)
        payload.push_back(static_cast<uint8_t>((seq >> shift) & 0xFF));
    payload.insert(payload.end(), body.begin(), body.end());
    return payload;
}

struct SessionTimers {
    std::optional<std::chrono::steady_clock::time_point> peer_wait_deadline;
};

template <typename Socket> struct SocketHolder {
    explicit SocketHolder(Socket&& s) : socket(std::move(s)) { }
    Socket socket;
};

template <typename Socket> Task<Frame, Work_Promise<SpinLock, Frame>> read_frame(Socket& socket, ServerContext& ctx)
{
    Frame   frame;
    uint8_t header[5];
    auto    hdr = co_await socket.recv_all(header, sizeof(header));
    if (hdr <= 0) {
        frame.type = 0xFF;
        co_return frame;
    }
    frame.type   = header[0];
    uint32_t len = (static_cast<uint32_t>(header[1]) << 24) | (static_cast<uint32_t>(header[2]) << 16)
        | (static_cast<uint32_t>(header[3]) << 8) | static_cast<uint32_t>(header[4]);
    if (len > ctx.max_payload) {
        frame.type = 0xFE; // signal oversize
        co_return frame;
    }
    frame.payload.resize(len);
    frame.raw.reserve(5 + len);
    frame.raw.insert(frame.raw.end(), header, header + 5);
    if (len > 0) {
        auto body = co_await socket.recv_all(frame.payload.data(), len);
        if (body <= 0) {
            frame.type = 0xFF;
            co_return frame;
        }
        frame.raw.insert(frame.raw.end(), frame.payload.begin(), frame.payload.end());
    }
    co_return frame;
}

nlohmann::json summary_json(const std::shared_ptr<ChatSession>& session)
{
    using namespace std::chrono;
    auto           now         = steady_clock::now();
    auto           duration_ms = duration_cast<milliseconds>(now - session->handshake_time).count();
    auto           peer_ptr    = session->peer.lock();
    bool           peer_active = peer_ptr && !peer_ptr->closing;
    nlohmann::json js          = {
        { "type",               "summary"                     },
        { "room",               session->info.room            },
        { "client_id",          session->info.client_id       },
        { "planned_send",       session->info.send_plan       },
        { "planned_receive",    session->info.expect_receive  },
        { "sent_from_client",   session->forwarded_to_peer    },
        { "forwarded_to_peer",  session->forwarded_to_peer    },
        { "received_from_peer", session->received_from_peer   },
        { "server_generated",   session->server_generated     },
        { "reported_done",      session->client_reported_done },
        { "duration_ms",        duration_ms                   },
        { "peer_active",        peer_active                   }
    };
    if (session->last_error.empty())
        js["error"] = nullptr;
    else
        js["error"] = session->last_error;
    return js;
}

void send_json(const std::shared_ptr<ChatSession>& session, const nlohmann::json& js)
{
    std::string text = js.dump();
    session->enqueue_frame(make_frame(kFrameTypeControl, std::string_view { text }));
}

bool plans_complete(const ChatSession& s)
{
    if (s.info.solo_mode) {
        return s.forwarded_to_peer >= s.info.send_plan && s.server_generated >= s.info.server_push;
    }
    return s.forwarded_to_peer >= s.info.send_plan && s.received_from_peer >= s.info.expect_receive
        && s.server_generated >= s.info.server_push;
}

template <typename Socket>
Task<void, Work_Promise<SpinLock, void>> writer_loop(std::shared_ptr<SocketHolder<Socket>> holder,
                                                     std::shared_ptr<ChatSession>          session)
{
    while (true) {
        co_await wait_sem_forever(*session->send_sem, *session->timer);
        std::vector<uint8_t> frame_data;
        {
            std::lock_guard lock(session->send_mutex);
            if (session->send_queue.empty())
                continue;
            frame_data = std::move(session->send_queue.front());
            session->send_queue.pop_front();
        }
        if (frame_data.empty())
            break;
        auto sent = co_await holder->socket.send_all(frame_data.data(), frame_data.size());
        if (sent <= 0) {
            session->last_error = "send failure";
            break;
        }
    }
    co_return;
}

void schedule_summary_if_ready(const std::shared_ptr<ChatSession>& session)
{
    if (session->summary_sent)
        return;
    if (!plans_complete(*session))
        return;
    session->summary_sent = true;
    send_json(session, summary_json(session));
    if (session->info.shutdown_after_send && !session->info.solo_mode)
        session->request_writer_stop();
}

void fail_session(ServerContext& server, const std::shared_ptr<ChatSession>& session, std::string message)
{
    cancel_wait_timeout(session);
    session->last_error = std::move(message);
    CO_WQ_LOG_WARN("[chat] session failing session=%p remote=%s room=%s client=%s reason=%s forwarded=%llu recv=%llu "
                   "push=%llu reported=%llu",
                   static_cast<void*>(session.get()),
                   session->remote_address.empty() ? "unknown" : session->remote_address.c_str(),
                   session->info.room.c_str(),
                   session->info.client_id.c_str(),
                   session->last_error.c_str(),
                   static_cast<unsigned long long>(session->forwarded_to_peer),
                   static_cast<unsigned long long>(session->received_from_peer),
                   static_cast<unsigned long long>(session->server_generated),
                   static_cast<unsigned long long>(session->client_reported_done));
    server.metrics.total_errors.fetch_add(1, std::memory_order_relaxed);
    nlohmann::json js {
        { "type",      "error"                 },
        { "room",      session->info.room      },
        { "client_id", session->info.client_id },
        { "message",   session->last_error     }
    };
    send_json(session, js);
    if (!session->summary_sent) {
        session->summary_sent = true;
        send_json(session, summary_json(session));
    }
    session->request_writer_stop();
}

void cancel_wait_timeout(const std::shared_ptr<ChatSession>& session)
{
    if (!session || !session->wait_timer_armed)
        return;
    session->wait_timer_armed = false;
    if (session->timer)
        session->timer->cancel(&session->wait_timer);
    session->wait_timer.server = nullptr;
    session->wait_timer.session.reset();
}

static void wait_timeout_callback(worknode* work)
{
    auto* timer = static_cast<ChatSession::WaitTimer*>(work);
    if (!timer)
        return;
    auto  session = timer->session.lock();
    auto* server  = timer->server;
    if (!server || !session)
        return;
    if (!session->wait_timer_armed)
        return;

    session->wait_timer_armed = false;
    timer->server             = nullptr;
    timer->session.reset();

    if (session->closing || session->peer.lock())
        return;

    session->last_error = "peer wait timeout";
    auto now            = std::chrono::steady_clock::now();
    auto waited_ms      = std::chrono::duration_cast<std::chrono::milliseconds>(now - session->handshake_time).count();
    CO_WQ_LOG_WARN("[chat] wait timeout session=%p remote=%s room=%s client=%s waited_ms=%lld timeout_ms=%u",
                   static_cast<void*>(session.get()),
                   session->remote_address.empty() ? "unknown" : session->remote_address.c_str(),
                   session->info.room.c_str(),
                   session->info.client_id.c_str(),
                   static_cast<long long>(waited_ms),
                   session->info.wait_timeout_ms);

    server->rooms.remove_if_waiting(session);
    session->closing = true;
    fail_session(*server, session, session->last_error);
}

void arm_wait_timeout(ServerContext& server, const std::shared_ptr<ChatSession>& session)
{
    if (!session || session->info.wait_timeout_ms == 0 || !session->timer || session->closing)
        return;
    if (session->wait_timer_armed)
        return;

    session->wait_timer_armed   = true;
    session->wait_timer.server  = &server;
    session->wait_timer.session = session;
    session->wait_timer.func    = wait_timeout_callback;
    INIT_LIST_HEAD(&session->wait_timer.ws_node);
    session->timer->post_delayed_work(&session->wait_timer, session->info.wait_timeout_ms);
}

void notify_peer_of_departure(ServerContext& server, const std::shared_ptr<ChatSession>& session)
{
    cancel_wait_timeout(session);
    auto peer = session->peer.lock();
    if (!peer)
        return;
    cancel_wait_timeout(peer);
    peer->peer.reset();
    peer->peer_gone = true;

    bool        peer_complete = plans_complete(*peer);
    std::string reason        = session->last_error.empty() ? "peer-disconnected" : session->last_error;

    nlohmann::json js {
        { "type",           "peer_closed"           },
        { "room",           peer->info.room         },
        { "peer_id",        session->info.client_id },
        { "reason",         reason                  },
        { "plans_complete", peer_complete           }
    };
    send_json(peer, js);

    if (!peer_complete) {
        peer->last_error = "peer disconnected before plan complete";
        server.metrics.total_errors.fetch_add(1, std::memory_order_relaxed);
        if (!peer->summary_sent) {
            peer->summary_sent = true;
            send_json(peer, summary_json(peer));
        }
        peer->request_writer_stop();
    } else {
        schedule_summary_if_ready(peer);
    }
}

void flush_pending_to_peer(const std::shared_ptr<ChatSession>& session, const std::shared_ptr<ChatSession>& peer)
{
    auto pending = session->take_pending();
    while (!pending.empty()) {
        auto raw = std::move(pending.front());
        pending.pop_front();
        peer->received_from_peer++;
        peer->enqueue_frame(std::move(raw));
    }
}

void schedule_server_push(const std::shared_ptr<ChatSession>& session)
{
    if (session->info.server_push == 0)
        return;
    std::vector<uint8_t> payload(session->info.payload_bytes, 0x53);
    for (uint32_t i = 0; i < session->info.server_push; ++i) {
        auto binary = make_binary_payload(static_cast<uint64_t>(i), payload);
        auto frame  = make_frame(kFrameTypeData, binary);
        session->server_generated++;
        session->enqueue_frame(std::move(frame));
    }
    schedule_summary_if_ready(session);
}

template <typename Socket>
Task<void, Work_Promise<SpinLock, void>>
reader_loop(std::shared_ptr<SocketHolder<Socket>> holder, std::shared_ptr<ChatSession> session, ServerContext& server)
{
    auto& socket = holder->socket;
    server.metrics.total_connections.fetch_add(1, std::memory_order_relaxed);
    server.metrics.active_connections.fetch_add(1, std::memory_order_relaxed);

    while (!session->closing) {
        auto frame = co_await read_frame(socket, server);
        if (frame.type == 0xFF) {
            session->closing = true;
            break;
        }
        if (frame.type == 0xFE) {
            fail_session(server, session, "frame exceeds server max payload");
            session->closing = true;
            break;
        }
        if (frame.type != kFrameTypeControl && frame.type != kFrameTypeData) {
            fail_session(server, session, "unknown frame type");
            session->closing = true;
            break;
        }

        if (!session->handshake_done) {
            if (frame.type != kFrameTypeControl) {
                fail_session(server, session, "expected handshake control frame");
                session->closing = true;
                break;
            }
            try {
                auto js         = nlohmann::json::parse(frame.payload.begin(), frame.payload.end());
                auto type_field = js.value("type", std::string {});
                if (type_field != "hello") {
                    fail_session(server, session, "first control frame must be hello");
                    session->closing = true;
                    break;
                }
                auto mode_field                   = js.value("mode", std::string {});
                session->info.solo_mode           = js.value("solo", false) || mode_field == "solo";
                session->info.room                = js.value("room", std::string {});
                session->info.client_id           = js.value("client_id", std::string {});
                session->info.send_plan           = js.value("send_plan", 0u);
                session->info.payload_bytes       = js.value("payload_bytes", 0u);
                session->info.expect_receive      = js.value("expect_receive", session->info.send_plan);
                session->info.server_push         = js.value("server_push", 0u);
                session->info.shutdown_after_send = js.value("shutdown_after_send", true);
                session->info.wait_timeout_ms     = js.value("wait_timeout_ms", 30000u);
                session->handshake_done           = true;
                bool require_room                 = !session->info.solo_mode;
                if (require_room && session->info.room.empty()) {
                    fail_session(server, session, "room must not be empty");
                    session->closing = true;
                    break;
                }
                if (session->info.client_id.empty()) {
                    auto ptr_val = reinterpret_cast<std::uintptr_t>(session.get());
                    if (session->info.room.empty())
                        session->info.client_id = "client#" + std::to_string(ptr_val);
                    else
                        session->info.client_id = session->info.room + "#" + std::to_string(ptr_val);
                }
                if (session->info.payload_bytes > server.max_payload) {
                    fail_session(server, session, "payload_bytes exceeds server limit");
                    session->closing = true;
                    break;
                }
                int active_handles = g_handle_connection_active.load(std::memory_order_acquire);
                CO_WQ_LOG_INFO(
                    "[chat] handshake session=%p remote=%s room=%s client=%s mode=%s send_plan=%u expect=%u payload=%u "
                    "server_push=%u shutdown_after_send=%d wait_timeout_ms=%u alloc_start=%d free_start=%d "
                    "alloc_total=%d free_total=%d balance=%d active_handles=%d",
                    static_cast<void*>(session.get()),
                    session->remote_address.empty() ? "unknown" : session->remote_address.c_str(),
                    session->info.room.c_str(),
                    session->info.client_id.c_str(),
                    session->info.solo_mode ? "solo" : "pair",
                    session->info.send_plan,
                    session->info.expect_receive,
                    session->info.payload_bytes,
                    session->info.server_push,
                    session->info.shutdown_after_send ? 1 : 0,
                    session->info.wait_timeout_ms,
                    session->alloc_start,
                    session->free_start,
                    sys_sta.malloc_cnt,
                    sys_sta.free_cnt,
                    sys_sta.malloc_cnt - sys_sta.free_cnt,
                    active_handles);
                std::shared_ptr<ChatSession> peer;
                if (!session->info.solo_mode)
                    peer = server.rooms.attach(session);

                nlohmann::json hello_ack {
                    { "type",   "hello_ack"                                                      },
                    { "status", session->info.solo_mode ? "solo" : (peer ? "paired" : "waiting") }
                };
                if (!session->info.room.empty())
                    hello_ack["room"] = session->info.room;
                hello_ack["mode"] = session->info.solo_mode ? "solo" : "pair";
                send_json(session, hello_ack);

                if (session->info.solo_mode) {
                    session->ready_sent = true;
                    nlohmann::json ready {
                        { "type",        "ready"                   },
                        { "mode",        "solo"                    },
                        { "peer_id",     nullptr                   },
                        { "server_push", session->info.server_push }
                    };
                    if (!session->info.room.empty())
                        ready["room"] = session->info.room;
                    send_json(session, ready);

                    if (session->info.server_push > 0) {
                        schedule_server_push(session);
                    }
                    continue;
                }

                if (!peer) {
                    arm_wait_timeout(server, session);
                    CO_WQ_LOG_INFO("[chat] waiting for peer session=%p remote=%s room=%s client=%s timeout_ms=%u",
                                   static_cast<void*>(session.get()),
                                   session->remote_address.empty() ? "unknown" : session->remote_address.c_str(),
                                   session->info.room.c_str(),
                                   session->info.client_id.c_str(),
                                   session->info.wait_timeout_ms);
                } else {
                    cancel_wait_timeout(session);
                    cancel_wait_timeout(peer);
                    session->ready_sent = true;
                    peer->ready_sent    = true;
                    server.metrics.total_pairings.fetch_add(1, std::memory_order_relaxed);
                    send_json(session,
                              nlohmann::json {
                                  { "type",               "ready"                   },
                                  { "room",               session->info.room        },
                                  { "peer_id",            peer->info.client_id      },
                                  { "peer_send_plan",     peer->info.send_plan      },
                                  { "peer_payload_bytes", peer->info.payload_bytes  },
                                  { "server_push",        session->info.server_push },
                                  { "mode",               "pair"                    }
                    });
                    send_json(peer,
                              nlohmann::json {
                                  { "type",               "ready"                     },
                                  { "room",               peer->info.room             },
                                  { "peer_id",            session->info.client_id     },
                                  { "peer_send_plan",     session->info.send_plan     },
                                  { "peer_payload_bytes", session->info.payload_bytes },
                                  { "server_push",        peer->info.server_push      },
                                  { "mode",               "pair"                      }
                    });
                    session->peer = peer;
                    peer->peer    = session;
                    flush_pending_to_peer(session, peer);
                    flush_pending_to_peer(peer, session);

                    if (session->info.server_push > 0)
                        schedule_server_push(session);
                    if (peer->info.server_push > 0) {
                        schedule_server_push(peer);
                    }
                    schedule_summary_if_ready(session);
                    schedule_summary_if_ready(peer);
                }
            } catch (const std::exception& ex) {
                fail_session(server, session, std::string("invalid handshake: ") + ex.what());
                session->closing = true;
                break;
            }
            continue;
        }

        if (frame.type == kFrameTypeControl) {
            try {
                auto js         = nlohmann::json::parse(frame.payload.begin(), frame.payload.end());
                auto type_field = js.value("type", std::string {});
                if (type_field == "done") {
                    session->client_reported_done = js.value("sent", session->client_reported_done);
                    schedule_summary_if_ready(session);
                } else if (type_field == "ping") {
                    send_json(session,
                              nlohmann::json {
                                  { "type", "pong" }
                    });
                }
            } catch (const std::exception& ex) {
                fail_session(server, session, std::string("invalid control frame: ") + ex.what());
                session->closing = true;
                break;
            }
            continue;
        }

        // data frame
        if (frame.payload.size() < 8) {
            fail_session(server, session, "data frame too small");
            session->closing = true;
            break;
        }
        uint64_t seq = read_u64_be(frame.payload.data());
        (void)seq; // sequence currently unused but parsed for validation hooks
        size_t body_len = frame.payload.size() - 8;
        if (session->info.payload_bytes && body_len != session->info.payload_bytes) {
            fail_session(server, session, "payload size mismatch");
            session->closing = true;
            break;
        }
        session->forwarded_to_peer++;
        if (session->forwarded_to_peer > session->info.send_plan && session->info.send_plan > 0) {
            fail_session(server, session, "send_plan exceeded");
            session->closing = true;
            break;
        }
        auto peer = session->peer.lock();
        if (session->info.solo_mode) {
            schedule_summary_if_ready(session);
            continue;
        }
        if (!peer || peer->closing) {
            session->append_pending(std::move(frame.raw));
            continue;
        }
        peer->received_from_peer++;
        peer->enqueue_frame(std::move(frame.raw));
        schedule_summary_if_ready(session);
        schedule_summary_if_ready(peer);
    }

    cancel_wait_timeout(session);
    server.rooms.remove_if_waiting(session);
    server.metrics.active_connections.fetch_sub(1, std::memory_order_relaxed);
    notify_peer_of_departure(server, session);
    if (!session->summary_sent) {
        session->summary_sent = true;
        send_json(session, summary_json(session));
    }
    session->request_writer_stop();
    co_return;
}

template <typename Socket> Task<void, Work_Promise<SpinLock, void>> handle_connection(Socket sock, ServerContext& ctx)
{
    struct HandleConnectionScope {
        std::atomic<int>& counter;
        void*             session_ptr { nullptr };
        std::string       remote_desc;
        int               active_on_enter { 0 };

        explicit HandleConnectionScope(std::atomic<int>& c, std::string remote)
            : counter(c), remote_desc(std::move(remote))
        {
            active_on_enter = counter.fetch_add(1, std::memory_order_acq_rel) + 1;
        }

        void record_session(void* ptr, std::string_view remote)
        {
            session_ptr = ptr;
            remote_desc.assign(remote.begin(), remote.end());
        }

        int active() const noexcept { return active_on_enter; }

        ~HandleConnectionScope()
        {
            int remaining = counter.fetch_sub(1, std::memory_order_acq_rel) - 1;
            CO_WQ_LOG_INFO("[chat] handle_connection destroyed session=%p remote=%s remaining_handles=%d "
                           "alloc_total=%d free_total=%d balance=%d",
                           session_ptr,
                           remote_desc.empty() ? "unknown" : remote_desc.c_str(),
                           remaining,
                           sys_sta.malloc_cnt,
                           sys_sta.free_cnt,
                           sys_sta.malloc_cnt - sys_sta.free_cnt);
        }
    };

    std::string remote_desc = describe_socket(sock);
    if (remote_desc.empty())
        remote_desc = "unknown";

    HandleConnectionScope scope(g_handle_connection_active, remote_desc);

    if constexpr (requires(Socket& s) { s.handshake(); }) {
        int hs = co_await sock.handshake();
        if (hs != 0) {
            CO_WQ_LOG_WARN("[chat] tls handshake failed remote=%s code=%d", remote_desc.c_str(), hs);
            CO_WQ_LOG_INFO("[chat] connection closed remote=%s reason=tls-handshake-failed", remote_desc.c_str());
            co_return;
        }
    }

    auto holder             = std::make_shared<SocketHolder<Socket>>(std::move(sock));
    auto session            = std::make_shared<ChatSession>(holder->socket.exec(), ctx.timer);
    session->remote_address = std::move(remote_desc);
    session->alloc_start    = sys_sta.malloc_cnt;
    session->free_start     = sys_sta.free_cnt;
    scope.record_session(session.get(), session->remote_address);
    CO_WQ_LOG_INFO("[chat] connection open session=%p remote=%s active_handles=%d",
                   static_cast<void*>(session.get()),
                   session->remote_address.empty() ? "unknown" : session->remote_address.c_str(),
                   scope.active());

    auto writer = writer_loop(holder, session);
    auto reader = reader_loop(holder, session, ctx);
    co_await when_all(writer, reader);

    const char* room           = session->info.room.empty() ? "-" : session->info.room.c_str();
    const char* client         = session->info.client_id.empty() ? "-" : session->info.client_id.c_str();
    const char* reason         = session->last_error.empty() ? "ok" : session->last_error.c_str();
    int         alloc_now      = sys_sta.malloc_cnt;
    int         free_now       = sys_sta.free_cnt;
    int         alloc_delta    = alloc_now - session->alloc_start;
    int         free_delta     = free_now - session->free_start;
    int         active_handles = g_handle_connection_active.load(std::memory_order_acquire);
    CO_WQ_LOG_INFO("[chat] connection closed session=%p remote=%s room=%s client=%s fwd=%llu recv=%llu push=%llu "
                   "reported=%llu reason=%s alloc_delta=%d free_delta=%d alloc_total=%d free_total=%d balance=%d "
                   "active_handles=%d",
                   static_cast<void*>(session.get()),
                   session->remote_address.empty() ? "unknown" : session->remote_address.c_str(),
                   room,
                   client,
                   static_cast<unsigned long long>(session->forwarded_to_peer),
                   static_cast<unsigned long long>(session->received_from_peer),
                   static_cast<unsigned long long>(session->server_generated),
                   static_cast<unsigned long long>(session->client_reported_done),
                   reason,
                   alloc_delta,
                   free_delta,
                   alloc_now,
                   free_now,
                   alloc_now - free_now,
                   active_handles);
    co_return;
}

Task<void, Work_Promise<SpinLock, void>> chat_listener(NetFdWorkqueue& fdwq,
                                                       std::string     host,
                                                       uint16_t        port,
                                                       ServerContext&  ctx
#if defined(USING_SSL)
                                                       ,
                                                       const net::tls_context* tls_ctx
#endif
)
{
    net::tcp_listener<SpinLock> listener(fdwq.base(), fdwq.reactor());
    listener.bind_listen(host, port, 512);
    g_listener_fd.store(listener.native_handle(), std::memory_order_release);
    CO_WQ_LOG_INFO("[chat] listening on %s:%u", host.c_str(), static_cast<unsigned>(port));

    while (!g_stop.load(std::memory_order_acquire)) {
        int fd = co_await listener.accept();
        if (fd == net::k_accept_fatal) {
            CO_WQ_LOG_ERROR("[chat] accept fatal error, stop listening");
            break;
        }
        if (fd < 0)
            continue;
#if defined(USING_SSL)
        if (tls_ctx) {
            try {
                auto tls_sock = fdwq.adopt_tls_socket(fd, *tls_ctx, net::tls_mode::Server);
                auto task     = handle_connection(std::move(tls_sock), ctx);
                post_to(task, fdwq.base());
            } catch (const std::exception& ex) {
                CO_WQ_LOG_ERROR("[chat] failed to setup TLS socket: %s", ex.what());
                net::os::close_fd(fd);
            }
        } else
#endif
        {
            auto tcp_sock = fdwq.adopt_tcp_socket(fd);
            auto task     = handle_connection(std::move(tcp_sock), ctx);
            post_to(task, fdwq.base());
        }
    }

    listener.close();
    g_listener_fd.store(net::os::invalid_fd(), std::memory_order_release);
    co_return;
}

struct Options {
    std::string host { "0.0.0.0" };
    uint16_t    port { 9100 };
#if defined(USING_SSL)
    uint16_t    tls_port { 9101 };
    std::string cert_path;
    std::string key_path;
    bool        tls_port_explicit { false };
#endif
    uint32_t                  max_payload { kMaxPayloadBytes };
    spdlog::level::level_enum log_level { spdlog::level::info };
    std::string               log_file { "logs/chat.log" };
    bool                      log_truncate { true };
    bool                      mirror_console { true };
    bool                      log_enabled { true };
    bool                      log_configured { false };
    std::string               resolved_log_file;
};

Options parse_args(int argc, char* argv[])
{
    Options opt;
    for (int i = 1; i < argc; ++i) {
        std::string_view arg(argv[i]);
        if (arg == "--host" && i + 1 < argc) {
            opt.host = argv[++i];
        } else if (arg == "--port" && i + 1 < argc) {
            opt.port = static_cast<uint16_t>(std::stoi(argv[++i]));
#if defined(USING_SSL)
            if (!opt.tls_port_explicit) {
                unsigned int candidate = static_cast<unsigned int>(opt.port) + 1u;
                if (candidate <= std::numeric_limits<uint16_t>::max())
                    opt.tls_port = static_cast<uint16_t>(candidate);
                else
                    opt.tls_port = 0;
            }
#endif
        } else if (arg == "--max-payload" && i + 1 < argc) {
            opt.max_payload = static_cast<uint32_t>(std::stoul(argv[++i]));
#if defined(USING_SSL)
        } else if (arg == "--tls-port" && i + 1 < argc) {
            opt.tls_port          = static_cast<uint16_t>(std::stoi(argv[++i]));
            opt.tls_port_explicit = true;
        } else if (arg == "--cert" && i + 1 < argc) {
            opt.cert_path = argv[++i];
        } else if (arg == "--key" && i + 1 < argc) {
            opt.key_path = argv[++i];
#endif
        } else if (arg == "--verbose" || arg == "--debug-log") {
            opt.log_level = spdlog::level::debug;
        } else if (arg == "--no-verbose") {
            opt.log_level = spdlog::level::info;
        } else if (arg == "--quiet") {
            opt.log_level = spdlog::level::warn;
        } else if (arg == "--log-file" && i + 1 < argc) {
            opt.log_file    = argv[++i];
            opt.log_enabled = true;
        } else if (arg == "--no-log-file") {
            opt.log_enabled = false;
        } else if (arg == "--log-truncate") {
            opt.log_truncate = true;
        } else if (arg == "--log-append" || arg == "--no-log-truncate") {
            opt.log_truncate = false;
        } else if (arg == "--no-console") {
            opt.mirror_console = false;
        } else if (arg == "--console-only") {
            opt.mirror_console = true;
            opt.log_enabled    = false;
        }
    }
    return opt;
}

std::optional<std::pair<std::filesystem::path, std::filesystem::path>> locate_default_tls_materials()
{
    std::error_code cwd_ec;
    auto            cwd = std::filesystem::current_path(cwd_ec);
    if (cwd_ec)
        cwd.clear();

    std::vector<std::filesystem::path> search_roots;
    if (!cwd.empty())
        search_roots.push_back(cwd);

    if (!cwd.empty()) {
        auto project_root = find_project_root(cwd);
        if (!project_root.empty() && project_root != cwd)
            search_roots.push_back(project_root);
    }

    for (const auto& root : search_roots) {
        auto cert_dir  = (root / "certs").lexically_normal();
        auto cert_path = (cert_dir / "server.crt").lexically_normal();
        auto key_path  = (cert_dir / "server.key").lexically_normal();

        std::error_code cert_ec;
        std::error_code key_ec;
        if (std::filesystem::exists(cert_path, cert_ec) && !cert_ec && std::filesystem::exists(key_path, key_ec)
            && !key_ec)
            return std::make_pair(std::move(cert_path), std::move(key_path));
    }

    return std::nullopt;
}

void setup_logging(Options& options)
{
    std::filesystem::path cwd_path;
    std::filesystem::path project_root;
    {
        std::error_code cwd_ec;
        cwd_path = std::filesystem::current_path(cwd_ec);
        if (cwd_ec)
            cwd_path.clear();
        if (!cwd_path.empty())
            project_root = find_project_root(cwd_path);
        if (project_root.empty())
            project_root = cwd_path;
    }

    bool        configured = false;
    std::string resolved_path;

    if (options.log_enabled && !options.log_file.empty()) {
        try {
            std::filesystem::path target(options.log_file);
            if (!target.is_absolute()) {
                if (!project_root.empty()) {
                    target = project_root / target;
                } else if (!cwd_path.empty()) {
                    target = cwd_path / target;
                }
            }
            target = target.lexically_normal();

            if (!target.empty()) {
                auto parent = target.parent_path();
                if (!parent.empty()) {
                    std::error_code dir_ec;
                    std::filesystem::create_directories(parent, dir_ec);
                    if (dir_ec) {
                        std::fprintf(stderr,
                                     "[chat] failed to create log directory %s: %s\n",
                                     parent.string().c_str(),
                                     dir_ec.message().c_str());
                    }
                }
            }

            co_wq::log::configure_file_logging(target.string(), options.log_truncate, options.mirror_console);
            configured    = true;
            resolved_path = target.string();
        } catch (const std::exception& ex) {
            std::fprintf(stderr, "[chat] failed to initialize log file %s: %s\n", options.log_file.c_str(), ex.what());
        }
    } else {
        // Fallback to console logging if file logging is disabled.
        options.mirror_console = true;
    }

    options.log_configured    = configured;
    options.resolved_log_file = resolved_path;

    auto logger = co_wq::log::get_logger();
    if (logger) {
        if (options.log_configured) {
            logger->set_level(spdlog::level::trace);
            if (!logger->sinks().empty()) {
                logger->sinks()[0]->set_level(spdlog::level::trace);
                if (options.mirror_console && logger->sinks().size() > 1)
                    logger->sinks()[1]->set_level(options.log_level);
            }
        } else {
            logger->set_level(options.log_level);
            for (auto& sink : logger->sinks())
                sink->set_level(options.log_level);
        }
    }

    auto level_view = spdlog::level::to_string_view(options.log_level);
    if (options.log_configured) {
        if (options.mirror_console) {
            CO_WQ_LOG_INFO("[chat] logging to %s (truncate=%d file_level=trace console_level=%.*s)",
                           options.resolved_log_file.c_str(),
                           options.log_truncate ? 1 : 0,
                           static_cast<int>(level_view.size()),
                           level_view.data());
        } else {
            CO_WQ_LOG_INFO("[chat] logging to %s (truncate=%d file_level=trace console=disabled)",
                           options.resolved_log_file.c_str(),
                           options.log_truncate ? 1 : 0);
        }
    } else {
        CO_WQ_LOG_INFO("[chat] logging to console only (level=%.*s)",
                       static_cast<int>(level_view.size()),
                       level_view.data());
    }
}

void log_metrics()
{
    auto   elapsed = std::chrono::steady_clock::now() - g_start_time;
    double seconds = std::chrono::duration_cast<std::chrono::duration<double>>(elapsed).count();
    CO_WQ_LOG_INFO(
        "[chat] uptime=%.1fs active=%llu total=%llu pairings=%llu errors=%llu allocations=%d frees=%d balance=%d",
        seconds,
        static_cast<unsigned long long>(g_metrics.active_connections.load()),
        static_cast<unsigned long long>(g_metrics.total_connections.load()),
        static_cast<unsigned long long>(g_metrics.total_pairings.load()),
        static_cast<unsigned long long>(g_metrics.total_errors.load()),
        sys_sta.malloc_cnt,
        sys_sta.free_cnt,
        sys_sta.malloc_cnt - sys_sta.free_cnt);
}

} // namespace

int main(int argc, char* argv[])
{
    auto options = parse_args(argc, argv);
    setup_logging(options);
#if defined(_WIN32)
    SetConsoleCtrlHandler(console_ctrl_handler, TRUE);
#else
    std::signal(SIGINT, sigint_handler);
#endif

    auto&          wq     = get_sys_workqueue(0);
    auto&          timers = get_sys_timer();
    NetFdWorkqueue fdwq(wq);

    g_start_time = std::chrono::steady_clock::now();
    ServerContext context { g_rooms, g_metrics, timers, options.max_payload };

#if defined(USING_SSL)
    if (options.tls_port != 0 && (options.cert_path.empty() || options.key_path.empty())) {
        if (auto defaults = locate_default_tls_materials()) {
            bool filled_cert = false;
            bool filled_key  = false;
            if (options.cert_path.empty()) {
                options.cert_path = defaults->first.string();
                filled_cert       = true;
            }
            if (options.key_path.empty()) {
                options.key_path = defaults->second.string();
                filled_key       = true;
            }
            if ((filled_cert || filled_key) && !options.cert_path.empty() && !options.key_path.empty()) {
                CO_WQ_LOG_INFO("[chat] TLS auto-discovered certificates cert=%s key=%s",
                               options.cert_path.c_str(),
                               options.key_path.c_str());
            }
        }
    }
    if (options.tls_port != 0 && (options.cert_path.empty() || options.key_path.empty())) {
        if (options.tls_port_explicit) {
            CO_WQ_LOG_ERROR("[chat] TLS port=%u requires --cert and --key", static_cast<unsigned>(options.tls_port));
            return 1;
        }
        CO_WQ_LOG_WARN("[chat] TLS port=%u disabled (missing --cert/--key)", static_cast<unsigned>(options.tls_port));
        options.tls_port = 0;
    }
#endif

    if (options.tls_port != 0) {
        CO_WQ_LOG_INFO("[chat] starting server host=%s tcp=%u tls=%u max_payload=%u",
                       options.host.c_str(),
                       static_cast<unsigned>(options.port),
                       static_cast<unsigned>(options.tls_port),
                       options.max_payload);
    } else {
        CO_WQ_LOG_INFO("[chat] starting server host=%s tcp=%u max_payload=%u",
                       options.host.c_str(),
                       static_cast<unsigned>(options.port),
                       options.max_payload);
    }

    std::atomic_bool metrics_thread_stop { false };
    std::thread      metrics_thread([&]() {
        using namespace std::chrono_literals;
        auto                     sleep_chunk = 100ms;
        auto                     sleep_goal  = 5s;
        std::chrono::nanoseconds elapsed { 0 };
        while (!metrics_thread_stop.load(std::memory_order_acquire)) {
            if (elapsed >= sleep_goal) {
                log_metrics();
                elapsed = std::chrono::nanoseconds { 0 };
            }
            std::this_thread::sleep_for(sleep_chunk);
            elapsed += sleep_chunk;
        }
        // final sample before exit
        log_metrics();
    });

#if defined(USING_SSL)
    std::optional<net::tls_context> tls_ctx;
    const net::tls_context*         tls_ptr = nullptr;
    if (options.tls_port != 0) {
        if (options.cert_path.empty() || options.key_path.empty()) {
            CO_WQ_LOG_ERROR("[chat] TLS port requires --cert and --key");
            return 1;
        }
        try {
            tls_ctx.emplace(net::tls_context::make_server_with_pem(options.cert_path, options.key_path));
            tls_ptr = &(*tls_ctx);
            CO_WQ_LOG_INFO("[chat] TLS enabled port=%u cert=%s key=%s",
                           static_cast<unsigned>(options.tls_port),
                           options.cert_path.c_str(),
                           options.key_path.c_str());
        } catch (const std::exception& ex) {
            CO_WQ_LOG_ERROR("[chat] failed to load TLS certificate: %s", ex.what());
            return 1;
        }
    }
#endif

    std::atomic_bool finished { false };
    auto             listener_task = chat_listener(fdwq,
                                       options.host,
                                       options.port,
                                       context
#if defined(USING_SSL)
                                       ,
                                       nullptr
#endif
    );
    {
        auto  coroutine      = listener_task.get();
        auto& promise        = coroutine.promise();
        promise.mUserData    = &finished;
        promise.mOnCompleted = [](Promise_base& pb) {
            auto* flag = static_cast<std::atomic_bool*>(pb.mUserData);
            if (flag)
                flag->store(true, std::memory_order_release);
        };
    }
    post_to(listener_task, wq);

#if defined(USING_SSL)
    Task<void, Work_Promise<SpinLock, void>> tls_listener_task { nullptr };
    if (options.tls_port != 0 && tls_ctx) {
        tls_listener_task        = chat_listener(fdwq, options.host, options.tls_port, context, tls_ptr);
        auto  tls_coroutine      = tls_listener_task.get();
        auto& tls_promise        = tls_coroutine.promise();
        tls_promise.mUserData    = &finished;
        tls_promise.mOnCompleted = [](Promise_base& pb) {
            auto* flag = static_cast<std::atomic_bool*>(pb.mUserData);
            if (flag)
                flag->store(true, std::memory_order_release);
        };
        post_to(tls_listener_task, wq);
    }
#endif

    std::optional<std::chrono::steady_clock::time_point> shutdown_deadline;
    while (!finished.load(std::memory_order_acquire)) {
        if (g_stop.load(std::memory_order_acquire)) {
            if (!shutdown_deadline.has_value()) {
                CO_WQ_LOG_INFO("[chat] stop requested, waiting for listener to exit");
                shutdown_deadline = std::chrono::steady_clock::now() + std::chrono::seconds(5);
            } else if (std::chrono::steady_clock::now() >= *shutdown_deadline) {
                CO_WQ_LOG_WARN("[chat] shutdown timeout reached; continuing with exit");
                break;
            }
        }
        std::this_thread::sleep_for(std::chrono::milliseconds(10));
    }

    metrics_thread_stop.store(true, std::memory_order_release);
    if (metrics_thread.joinable())
        metrics_thread.join();
    log_metrics();
    CO_WQ_LOG_INFO("[chat] shutdown complete");
    return 0;
}

#else
int main()
{
    CO_WQ_LOG_WARN("co_chat disabled (requires USING_NET)");
    return 0;
}
#endif
